const l=n=>n===1?0:1,d=n=>n===1?0:1,p=(n,e)=>{if(e===2)return n===1?0:1;const t=n%100;return t%10===1&&t!==11?0:t%10>=2&&t%10<=4&&!(t>=10&&t<15)?1:2},f=(n,e)=>{let t=0,r=n[e[0]];for(;t<e.length;){if(typeof r=="string"&&t+1===e.length)return r;if(typeof r!="object")return;r=r[e[++t]]}return r},m=(n,e)=>Object.keys(e).reduce((t,r)=>{const s=new RegExp(`\\{${r}\\}`,"g"),i=String(e[r]);return t.replace(s,i)},n),h=(n,e,t=void 0)=>{const r=f(n,e);return typeof r=="string"&&t?m(r,t):r},o=n=>{throw new Error(n)},g=(n,e,t,r=void 0)=>{const s=t.split(".");if(n){const i=h(e[n]??{},s,r);return typeof i!="object"?i:o(`Translation for "${n}:${t}" is not translatable`)}},b=(n,e,t)=>{const r=n.split("|");return r[t(e,r.length)]};class c{parent;messages;computed;pluralization;fallback;constructor(e=void 0,t=void 0){this.parent=t,this.messages=e?.messages??{},this.computed=e?.computed??{},this.pluralization={"en-GB":l,"es-ES":d,"ru-RU":p,...e?.pluralization??{}},this.fallback=e?.fallback}t(e,t,r=void 0){try{const s=i=>g(i,this.messages,t,r);return s(e)??s(this.fallback)??o(`Translation for "${t}" does not exists`)}catch(s){if(this.parent)return this.parent.t(e,t,r);throw s}}tc(e,t,r,s=void 0){return b(this.t(e,t,s),r,this.pluralization[e])}compute(e,t,r){const s=this.computed[t];return s?s(u(this,e),r):this.parent?this.parent.compute(e,t,r):o("Key "+t+" is not registered")}extend(e){return new c({pluralization:this.pluralization,fallback:this.fallback,...e},this)}}const u=(n,e)=>({t(t,r=void 0){return n.t(e,t,r)},tc(t,r,s=void 0){return n.tc(e,t,r,s)},compute(t,r){return n.compute(e,t,r)}}),a="en-GB",v=(n=void 0,e=void 0)=>{const t=new c({...n,fallback:a},e),r=(s,i=void 0)=>i?s.extend(i):s;return{i18n:t,init:(s,i=void 0)=>u(r(t,i),s),fallback:a}};export{v as d};
